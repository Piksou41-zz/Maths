"use strict";

const { verifArray, verifMaxMin, verif } = require("./functions");
const { NegativeArgumentError } = require("./Errors/NegativeArgumentError");

const constants = {
    E: 2.718281828459045,
    LN2: 0.6931471805599453,
    LN10: 2.302585092994046,
    LOG2E: 1.4426950408889634,
    LOG10E: 0.4342944819032518,
    PI: 3.141592653589793,
    PHI: 1.618033988749895,
    SQRT1_2: 0.7071067811865476,
    SQRT2: 1.414213562373095,
};

module.exports.Maths = class Maths {
    constructor() {
        return "Mathematics are fantastic !";
    };

    //#region Getters
    get E() {
        return constants.E;
    };

    get LN2() {
        return constants.LN2;
    };
    
    get LN10() {
        return constants.LN10;
    };

    get LOG2E() {
        return constants.LOG2E;
    };

    get LOG10E() {
        return constants.LOG10E;
    };

    get PI() {
        return constants.PI;
    };

    get PHI() {
        return constants.PHI;
    };

    get SQRT1_2() {
        return constants.SQRT1_2;
    };

    get SQRT2() {
        return constants.SQRT2;
    };
    //#endregion Getters

    //#region functions
    add(...x) {
        verifArray(x);
        return x.reduce((accu, current) => accu + current);
    };

    remove(...x) {
        verifArray(x);
        return x.reduce((accu, current) => accu - current);
    };

    multiply(...x) {
        verifArray(x);
        return x.reduce((accu, current) => accu * current);
    };

    divide(...x) {
        verifArray(x);
        return x.reduce((accu, current) => accu / current);
    };

    divx(x) {
        verif(x);
        if(x === 0) throw new NegativeArgumentError("Argument can not be negative.");
        return 1 / x;
    };

    abs(x) {
        verif(x);

        if(x == 0) return 0;
        else if(x > 0) return x;
        else if(x < 0) return -x
    };

    cbrt(x) {
        verif(x);
    
        return x ** (1/3);
    };

    ceil(x) {
        verif(x);
        
        if(Number.isInteger(x)) return x;
        else if(!Number.isInteger(x) && x > 0)return ~~(x) + 1;
        else return parseInt(x);
    };

    exp(x) {
        verif(x);

        return constants.E ** x;
    };

    expm1(x) {
        verif(x);

        return (new Maths).exp(x) - 1;
    };

    expo10(x) {
        verif(x);
    
        return 10 ** x;
    };

    fact(x) {
        verif(x);
        if(x < 0) throw new Error("Negative numbers are not supported.");
        if(x === 0) return 1;
    
        let result = 1;
        for(let i = 1; i <= x; i++) result *= i;
        
        return result;
    };

    floor(x) {
        verif(x);
    
        if(Number.isInteger(x)) return x;
        else if(x < 0 && !Number.isInteger(x)) return ~~(x) - 1;
        else return parseInt(x);
    };

    max(arr) {
        verifMaxMin(arr);

        let len = arr.length;
        let max = -Infinity;
        while(len--) if(arr[len] > max) max = arr[len];
        
        return max;
    };

    min(arr) {
        verifMaxMin(arr);
    
        let len = arr.length;
        let min = Infinity;
        while(len--) if(arr[len] < min) min = arr[len];
        
        return min;
    };

    neg(x) {
        verif(x);
    
        if(x === 0) throw new NegativeArgumentError("Argument can not be negative.");
        else if(x < 0) return x;
        else return -x;
    };

    pow(base, exposant) {
        verif(base);
        verif(exposant);
    
        return base ** exposant;
    };

    root(x) {
        verif(x);
    
        return x ** 2;
    };

    trunc(x) {
        verif(x);

        if(x > 0) return (new Maths).floor(x);
        else return (new Maths).ceil(x);
    };

    sqrt(x) {
        if(x < 0) return "i";
        verif(x);
    
        return x ** (1/2);
    };

    sign(x) {
        verif(x);
    
        if(x == 0) throw new NegativeArgumentError("Argument can not be negative.");
        else if(x > 0) return "positive";
        else return "negative";
    };

    root3(x) {
        verif(x);
    
        return x ** 3;
    };

    random() {
        let lastRand = .5; 
        lastRand = (new Date().getTime() * (new Maths).PI * lastRand) % 1;
        
        return lastRand;
    };

    log2(n) {
        verif(n);

        let count = 0;
        while(n !== 2) {
            n /= 2;
            count ++;
        };
        return count + 1;
    };

    toDegrees(rad) {
        verif(rad);

        return rad * (180 / (new Maths).PI);
    };

    toRadians(deg) {
        verif(deg);

        return deg * ((new Maths).PI / 180);
    };
    //#endregion functions
};